@type
native_to_universal :: * -> String -> File -> String
universal_to_native :: String -> String -> *


@source R

# Convert native data structure to file or literal
native_to_universal <- function(x, type, outdir){
  f <- ""
  if(is.atomic(x) && length(x) == 1){
    f <- as.character(x)
  } else if(type == "void"){
    f <- ""
  } else {
    f <- tempfile(pattern="m1_R_", tmpdir=outdir, fileext=".out")
    require(readr)
    if(is.data.frame(x)){
      write_tsv(x, path=f)
    } else if(is.list(x)) {
      write(unlist(x), file=f, ncolumns=1)
    } else if(is.vector(x)) {
      write(x, file=f, ncolumns=1)
    } else if(is.null(x)) {
      f <- ""
    } else {
      msg = sprintf("R: Cannot export object of class '%s'", class(x))
      warning(msg)
    }
  }
  f
}

# Convert text or binary to native data structure
number_types  <- c("Int", "[Int]")
string_types  <- c("String", "[String]", "File")
logical_types <- c("Bool", "[Bool]")
universal_to_native <- function(x, type){
  if( any(type %in% number_types) ){
    d <- as.numeric(x)
  }
  else if( any(type %in% string_types) ){
    d <- as.character(x)
  }
  else if( any(type %in% logical_types) ){
    d <- as.logical(x)
  }
  else if( type == "void" ){
    d <- NULL
  }
  else if( type == "Text" ){
    d <- read_lines(x)
  }
  else {
    warning("Blindly reading unknown type as Table or Vector")
    d <- read_tsv(x)
    if(ncol(d) == 1){
      d <- d[[1]]
    }
  }
  d
}



@source sh

native_to_universal (){
    x=$1
    vtype=$2
    outdir=$3
    if [[ $vtype == "Int"    ||
          $vtype == "String" ||
          $vtype == "Num"    ||
          $vtype == "Bool"   ||
          $vtype == "File" ]]
    then
        echo "$x"
    elif [[ $vtype == "void" ]]
    then
        echo -n ""
    else
        tmpfile=$outdir/sh_$RANDOM$RANDOM
        touch $tmpfile || echo "Cannot write to temporary file $tmpfile" >&2
        if [[ -r $x ]]
        then
            cat $x > $tmpfile
            echo "$tmpfile"
        else
            echo "Type ($vtype) input error, expected file" >&2
        fi
    fi
}

universal_to_native (){
    x=$1
    vtype=$2
    if [[ $vtype == "Int"    ||
          $vtype == "String" ||
          $vtype == "Num"    ||
          $vtype == "Bool"   ||
          $vtype == "File" ]]
    then
        echo "$x"
    elif [[ $vtype == "void" ]]
    then
        echo -n ""
    else
        if [[ -r "$x" ]]
        then
            cat "$x"
        else
            echo "(sh) cannot cat file '$x' (type='$2')" >&2
        fi
    fi
}


@source py

import tempfile

def __loc_parse_list(x, typ, sep="\n"):
    if not isinstance(x, (list, tuple, set)):
        msg = "Expected iterable class for input of type '%s', got '%s'"
        print(msg % (str(type(x))), file=sys.stderr)

    typ = typ[1:-1]
    if typ[0] == '[':
        x = ["\t".join([str(s) for s in ss]) for ss in x]
        typ = typ[1:-1]

    if typ[0] == '[':
        msg = "Arrays of dimension greater than 2 are not supported (in type '[[%s]]')"
        print(msg % typ, file=sys.stderr)

    return '\n'.join((str(s) for s in x))

# Convert native data structure to file or literal
def native_to_universal(x, typ, outdir):
    f = None
    if typ in ("String", "File"):
        f = str(x)
    elif typ == "Int":
        f = int(x)
    elif typ == "Num":
        f = float(x)
    elif typ == "Bool":
        f = 1 if x else 0
    elif typ == "void":
        f = ""
    else:
        tmp = tempfile.NamedTemporaryFile(
            prefix = "py_%s" % typ,
            dir    = outdir,
            delete = False
        )
        f = tmp.name

        if isinstance(x, dict):
            x = x.items()

        data = None

        if typ[0] == '[':
            data = __loc_parse_list(x, typ)
        elif typ == "Text" and isinstance(x, (list,tuple,set)):
            data = "\n".join((str(s) for s in x))
        else:
            msg = "Py: Cannot export object of class '%s', guessing" % type(x)
            print(msg, file=sys.stderr)
            data = str(x)

        tmp.write(data.encode("ASCII"))
        tmp.write("\n".encode("ASCII"))

    return str(f)

# Convert text or binary to native data structure
number_types  = ("Int", "[Int]")
string_types  = ("String", "[String]", "File")
logical_types = ("Bool", "[Bool]")
caster = {
    "Int":int,
    "Num":float,
    "String":str,
    "File":str,
    "Bool":bool
}
def universal_to_native(x, type):
    if typ in caster:
        d = caster[typ](x)
    elif typ == "void":
        d = ""
    elif typ == "Text":
        with open(x, "r") as f:
            d = f.readlines()
    elif typ[0] == '[':
        with open(x, "r") as f:
            d = f.readlines()
        typ = typ[1:-1]
        if typ in caster:
            cast = caster[typ]
            d = [cast(e) for e in d]
    else:
        d = str(x)
    return d
