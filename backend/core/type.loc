@type
native_to_universal :: * -> String -> File -> String
universal_to_native :: String -> String -> *


@source R

loc_universal_form <- function(x){
    if(is.data.frame(x)){
        for(i in 1:ncol(x)){
            if(is.logical(x[[i]])){
                x[[i]] <- as.integer(x[[i]])
            }
        }
    } else if(!is.list(x) && is.vector(x) && is.logical(x)) {
        x <- as.integer(x)
    }
    x
}

# Convert text or binary to native data structure
loc_number_types  <- c("Int", "[Int]", "Num", "[Num]")
loc_string_types  <- c("String", "[String]", "File")
loc_logical_types <- c("Bool", "[Bool]")

loc_primitive <- c("Int", "Num", "String", "File", "Bool")

loc_cast_native <- list(
    "Int"    = as.integer,
    "Num"    = as.numeric,
    "String" = as.character,
    "File"   = as.character,
    "Bool"   = function(x) { as.logical(as.integer(x)) },
    "Text"   = read_lines,
    "void"   = function(x) { NULL }
)


loc_is_tuple <- function(t){
    grepl("^\\(.*\\)$", t)
}

loc_split_tuple <- function(t){
    unlist(strsplit(gsub("^\\(|\\)$", "", t), ","))
}

loc_is_primitive_tuple <- function(t){
    loc_is_tuple(t) &&
        all(loc_split_tuple(t) %in% loc_primitive)
}

# Convert native data structure to file or literal
native_to_universal <- function(x, type, outdir){
  f <- ""

  if(type %in% c("Int", "Num", "String", "File")){
    f <- as.character(x)
  } else if(type == "Bool"){
    f <- as.character(as.integer(x))
  } else if(type == "void"){
    f <- ""
  } else {
    f <- tempfile(pattern="m1_R_", tmpdir=outdir, fileext=".out")
    require(readr)
    x <- loc_universal_form(x)
    if(is.data.frame(x) || is.matrix(x)){
      write_tsv(x, path=f, col_names=FALSE)
    } else if(is.list(x)) {
      if(loc_is_primitive_tuple(type)){
        ts <- loc_split_tuple(type)
        boolids <- which(ts == "Bool")
        x[boolids] <- lapply(x[boolids], as.integer)
        x <- paste(unlist(x), collapse="\t")
        write(x, append=TRUE, file=f, ncolumns=1)
      } else {
        write(unlist(x), append=TRUE, file=f, ncolumns=1)
      }
    } else if(is.vector(x)) {
      write(x, append=TRUE, file=f, ncolumns=1)
    } else {
      msg = sprintf("R: Cannot export object of class '%s'", class(x))
      warning(msg)
      f = ""
    }
  }
  f
}

loc_is_list <- function(type){ grepl("^\\[[^[]", type) }
loc_is_table <- function(type){ grepl("^\\[\\[[^[]", type) }
loc_base_type <- function(type){ gsub("(^\\[*|\\]*$)", "", type) }

loc_col_types <- c("Int"="i","String"="c","Num"="d","Bool"="l")

universal_to_native <- function(x, type){
  if(loc_is_list(type)){
    col_type <- loc_col_types[loc_base_type(type)]
    d <- read_tsv(
        x,
        col_names=FALSE,
        col_types=col_type
    )
    d <- d[[1]]
  } else if (loc_is_table(type)){
    col_type <- loc_col_types[loc_base_type(type)]
    d <- read_tsv(
        x,
        col_names=FALSE,
        col_types=cols(.default = col_type)
    )
  } else if(loc_is_primitive_tuple(type)) {
    col_types <- paste(loc_col_types[loc_split_tuple(type)], collapse="")
    d <- read_tsv(
        x,
        col_names=FALSE,
        col_types=col_types
    )
    d <- as.list(d[1, ])
    names(d) <- NULL
  } else if(type %in% names(loc_cast_native)){
    d <- loc_cast_native[[type]](x)
  } else {
    msg <- "(R) Unsupported type '%s' treated as literal"
    warning(sprintf(msg, type))
    d <- x
  }
  d
}



@source sh

native_to_universal (){
    x=$1
    vtype=$2
    outdir=$3
    if [[ $vtype == "Int"    ||
          $vtype == "String" ||
          $vtype == "Num"    ||
          $vtype == "Bool"   ||
          $vtype == "File" ]]
    then
        echo "$x"
    elif [[ $vtype == "void" ]]
    then
        echo -n ""
    else
        tmpfile=$outdir/sh_$RANDOM$RANDOM
        touch $tmpfile || echo "Cannot write to temporary file $tmpfile" >&2
        if [[ -r $x ]]
        then
            cat $x > $tmpfile
            echo "$tmpfile"
        else
            echo "Type ($vtype) input error, expected file" >&2
        fi
    fi
}

universal_to_native (){
    x=$1
    vtype=$2
    if [[ $vtype == "Int"    ||
          $vtype == "String" ||
          $vtype == "Num"    ||
          $vtype == "Bool"   ||
          $vtype == "File" ]]
    then
        echo "$x"
    elif [[ $vtype == "void" ]]
    then
        echo -n ""
    else
        if [[ -r "$x" ]]
        then
            cat "$x"
        else
            echo "(sh) cannot cat file '$x' (type='$2')" >&2
        fi
    fi
}


@source py

import tempfile

loc_cast_native = {
    "String" : str,
    "File"   : str,
    "Int"    : int,
    "Num"    : float,
    "Bool"   : bool,
    "*"      : str,
    "void"   : lambda x : None
}

loc_cast_universal = {
    "String" : str,
    "File"   : str,
    "Int"    : str,
    "Num"    : str,
    "Bool"   : lambda x : str(int(x)),
    "*"      : str,
    "void"   : lambda x : None
}

# Convert text or binary to native data structure
loc_number_types  = ("Int", "[Int]")
loc_string_types  = ("String", "[String]", "File")
loc_logical_types = ("Bool", "[Bool]")


def __loc_parse_list(x, typ):
    if not isinstance(x, (list, tuple, set)):
        msg = "Expected iterable class for input of type '%s', got '%s'"
        print(msg % (str(type(x))), file=sys.stderr)

    d = None

    typ = typ[1:-1]
    if typ[0] == '[':
        typ = typ[1:-1]
        try:
            cast = loc_cast_universal[typ]
            d = ("\t".join([cast(s) for s in ss]) for ss in x)
        except KeyError:
            msg = "Type '%s' is not legal in a table"
            print(msg % typ, file=sys.stderr)
    else:
        try:
            cast = loc_cast_universal[typ]
            d = (cast(s) for s in x)
        except KeyError:
            msg = "Type '%s' is not legal in a vector"
            print(msg % typ, file=sys.stderr)

    return d

def loc_is_tuple(typ):
    return typ[0] == '(' and ',' in typ

def is_primitive_tuple(typ):
    typ = typ[1:-1].split(',')
    return all((t in loc_cast_universal) for t in typ)

# Convert native data structure to file or literal
def native_to_universal(x, typ, outdir):
    f = None
    if typ in loc_cast_universal:
        caster = loc_cast_universal[typ]
        f = caster(x)
    else:
        tmp = tempfile.NamedTemporaryFile(
            prefix = "py_",
            dir    = outdir,
            delete = False
        )
        f = tmp.name

        if isinstance(x, dict):
            x = x.items()

        data = None

        if typ[0] == '[':
            data = '\n'.join(__loc_parse_list(x, typ))
        elif loc_is_tuple(typ):
            if is_primitive_tuple(typ):
                data = "\t".join((str(s) for s in x))
            else:
                msg = "Py: No handler complex tuples '%s'"
                print(msg % typ, file=sys.stderr)
                data = str(x)
        elif typ == "Text":
            if isinstance(x, (list,tuple,set)):
                data = "\n".join((str(s) for s in x))
            else:
                data = str(x)
        else:
            msg = "Py: No handler for type '%s' ('%s'), guessing"
            print(msg % (typ, type(x)), file=sys.stderr)
            data = str(x)

        tmp.write(data.encode("ASCII"))
        tmp.write("\n".encode("ASCII"))

    return f

def universal_to_native(x, typ):
    if typ in loc_cast_native:
        d = loc_cast_native[typ](x)
    elif typ == "void":
        d = ""
    elif typ == "Text":
        with open(x.rstrip(), "r") as f:
            d = [s.rstrip() for s in f.readlines()]
    elif loc_is_tuple(typ):
        if is_primitive_tuple(typ):
            with open(x.strip(), "r") as f:
                d = f.readlines()
                if(len(d) != 1):
                    print("Expected primitive tuple to be 1 line", file=sys.stderr)
                d = d[0].rstrip()
            d = tuple(d.split("\t"))
        else:
            msg = "Py: No handler for reading complex tuple '%s'"
            print(msg % typ, file=sys.stderr)
            d = str(x)
    elif typ[0] == '[':
        with open(x.strip(), "r") as f:
            d = [s.rstrip() for s in f.readlines()]
        if typ[1] == '[':
            try:
                cast = loc_cast_native[typ[2:-2]]
            except KeyError:
                cast = str
            d = [[cast(s) for s in ss.split("\t")] for ss in d]
        else:
            try:
                cast = loc_cast_native[typ[1:-1]]
            except KeyError:
                cast = str
            d = [cast(s) for s in d]
    else:
        d = str(x)
    return d
