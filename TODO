# Usability

 [ ] Make a Docker image

# RDF representation

 [ ] Write specification
 [x] Handle import scoping (maybe follow R environment model)
 [x] Remove dependency on `arq` (too slow)

# Error reporting

 * In the compiler ...
   [ ] Add meaningful error messages to parser
   [ ] Replace the naked `error` calls everywhere

 * In the generated code ...

   [ ] If an error is caught, report the offending Morloc file and line of
       code. This will require this information be added to the generated RDF
       graph (which needs to be done anyway). 

# Testing

 [ ] Add golden tests for generated output. This will be a collection of
     workflows, scripts to call them, and the recorded output.
 [ ] Add benchmarking
 [ ] Add code linting
 [ ] Add test coverage reports

# UI and configuration 

 * in the top-level usage printout:
   [ ] print the short doc string

 * in the function-specific detailed printout:
   [ ] print the type signature of each exported function
   [ ] print the long doc string

 * configuration
   [ ] parse to RDF and upload to local SPARQL database

# typechecking

 [x] Add a full Hindley-Milner type inference system, this is just one layer of
     the type system, but is an essential one. Eventually this can be ported
     to the rule-engine.
 [ ] specify rules in OWL, join this with the morloc RDF, and then check validity
 [x] port this typechecker to Morloc

# Features

 [ ] constraint system
 [x] add higher-order functions
 [ ] demonstrate parameter handling
 [ ] add sum types
 [ ] allow function docstrings
 [ ] allow caching
 [ ] allow effect handling hooks

 * add support for more languages
   [ ] bash
   [+] C
   [ ] Haskell
   [+] C++

# Documentation

 [ ] Write TensorFlow example
 [ ] Add haddock for every function
 [ ] Write basic manual

 * Extend README with
   [ ] A discussion of the architecture (SPARQL, JSON, MorlocIO, etc)
   [ ] A deeper discussion of the type system
   [ ] More examples
   [ ] A contribution and future work section

# Libraries

 * Extend the libraries
   [x] Add higher-order function libraries (map, foldl, foldr, reduce, filter).
       This will require handling for choosing a concrete function from among
       many language-specific alternatives. In C-morloc, the user specified the
       language of each function. I want to automate the choice.
   [ ] Add taxonomy library
   [ ] Add `math` library
       [x] basic functions from `math.h`
       [ ] advanced functions from GNU Scientific Library
   [ ] Add `learning` library for machine learning
   [ ] Add `stat` library
   [ ] Add `physics` library

 * Determine library hierarchy
   [ ] Where do core files go? (e.g., `$MORLOC_HOME/lib/core/*`)
   [ ] Do we separate the *.loc files from the other language files?

# Implementation

 [ ] Consider replacing Megaparsec parser with traditional LR parser, i.e. the
     Haskell equivalents of Flex and Bison, Alex and Happy. 

 [ ] Disentangle MAST generation from the parser. First pass the script through
 a lexer (Alex) to create a token stream. The parser (Happy) generates a
 Haskell data structure from the token stream. The Haskell data structure is
 then converted to RDF (MAST). The semantic engine reads MAST to generate VAST.
 The linker reads VAST to generate LAST (local abstract syntax tree) which is
 finally converted by the generator to local source code.
