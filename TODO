# Features

 [x] composable serialization/deserialization functions
 [x] composable default types
 [ ] auto-casting
 [ ] side-effect handling
 [x] higher-order functions
 [ ] constraint system
 [ ] sum types

 * manifold hooks
   [ ] function docstrings
   [ ] caching
   [ ] effect handling hooks
   [ ] attach effects to labeled nodes in a composition 
   [x] set function parameters in external config (currying)

 * add support for more languages
   [+] R
   [+] Python3
   [+] C++
   [.] C
   [ ] bash
   [ ] Haskell
   [ ] Perl
   [ ] Julia

# Refactoring

 [ ] Replace Type with SolvedType after typechecking (see 6bdcf5a4): 

```
data SolvedType
  = VarS TVar
  | FunS Type SolvedType
  | ArrS TVar [SolvedType]
  | NamS TVar [(Text, SolvedType)]
```

 [ ] Build a tree object in the parser and typecheck it, rather than the
     awkward Module list

# Usability

 [ ] Make a Docker image

# RDF representation

 [ ] Write specification
 [x] Handle import scoping (maybe follow R environment model)
 [x] Remove dependency on `arq` (too slow)

# Error reporting

 * In the compiler ...

   [ ] Add meaningful error messages to parser
   [ ] Replace the naked `error` calls everywhere

 * In the generated code ...

   [ ] On exceptions in generated code, return Morloc file and line number
   [ ] Raise errors in pools when no manifold is found

# Testing

 [x] unit tests covering the typechecker
 [x] golden tests over generated output
 [ ] performance profiling
 [ ] code linting
 [ ] test coverage reports
 [ ] property testing (resurrect it)

# Syntax

 [ ] Remove semicolon requirement

# UI and configuration 

 * in the top-level usage printout:
   [ ] print the short doc string

 * in the function-specific detailed printout:
   [ ] print the type signature of each exported function
   [ ] print the long doc string

 * configuration
   [ ] parse to RDF and upload to local SPARQL database

# typechecking

 [x] Add a full type inference system, this is just one layer of the type
     system, but is an essential one. Eventually this can be ported to the
     rule-engine.
 [ ] specify rules in OWL, join this with the morloc RDF, and then check validity

# Documentation

 [ ] Write TensorFlow example
 [ ] Add haddock for every function
 [ ] Write basic manual

 * Extend README with
   [ ] A discussion of the architecture (SPARQL, JSON, MorlocIO, etc)
   [ ] A deeper discussion of the type system
   [ ] More examples
   [ ] A contribution and future work section

# Libraries

 * Extend the libraries
   [x] Add higher-order function libraries (map, foldl, foldr, reduce, filter).
       This will require handling for choosing a concrete function from among
       many language-specific alternatives. In C-morloc, the user specified the
       language of each function. I want to automate the choice.
   [ ] Add taxonomy library
   [ ] Add `math` library
       [x] basic functions from `math.h`
       [ ] advanced functions from GNU Scientific Library
   [ ] Add `learning` library for machine learning
   [ ] Add `stat` library
   [ ] Add `physics` library

 * Determine library hierarchy
   [ ] Where do core files go? (e.g., `$MORLOC_HOME/lib/core/*`)
   [ ] Do we separate the *.loc files from the other language files?
