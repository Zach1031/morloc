# Usability

 [ ] Make a Docker image

# RDF representation

 [ ] Write specification
 [ ] Handle import scoping (maybe follow R environment model)
 [ ] Remove dependency on `arq` (too slow)

# Error reporting

 * In the compiler ...
   [ ] Add meaningful error messages to parser
   [ ] Replace the naked `error` calls everywhere

 * In the generated code ...

   [ ] If an error is caught, report the offending Morloc file and line of
       code. This will require this information be added to the generated RDF
       graph (which needs to be done anyway). 

# Testing

 [ ] Add golden tests for generated output. This will be a collection of
     workflows, scripts to call them, and the recorded output.
 [ ] Add benchmarking
 [ ] Add code linting
 [ ] Add test coverage reports

# UI and configuration 

 * in the top-level usage printout:
   [ ] print the short doc string

 * in the function-specific detailed printout:
   [ ] print the type signature of each exported function
   [ ] print the long doc string

 * configuration
   [ ] parse to RDF and upload to local SPARQL database

# typechecking

 [ ] specify rules in OWL, join this with the morloc RDF, and then check validity
 [ ] port this typechecker to Morloc

# Features

 [ ] constraint system
 [ ] add higher-order functions
 [ ] demonstrate parameter handling
 [ ] add sum types
 [ ] allow function docstrings
 [ ] allow caching
 [ ] allow effect handling hooks

 * add support for more languages
   [ ] bash
   [.] C
   [ ] Haskell
   [ ] C++

# Documentation

 [ ] Write TensorFlow example
 [ ] Add haddock for every function
 [ ] Write basic manual

 * Extend README with
   [ ] A discussion of the architecture (SPARQL, JSON, MorlocIO, etc)
   [ ] A deeper discussion of the type system
   [ ] More examples
   [ ] A contribution and future work section

# Libraries

 * Extend the libraries
   [ ] Add higher-order function libraries (map, foldl, foldr, reduce, filter).
       This will require handling for choosing a concrete function from among
       many language-specific alternatives. In C-morloc, the user specified the
       language of each function. I want to automate the choice.
   [ ] Add taxonomy library
   [ ] Add `learning` library for machine learning
   [ ] Add `stat` library
   [ ] Add `physics` library

 * Determine library hierarchy
   [ ] Where do core files go? (e.g., `$MORLOC_HOME/lib/core/*`)
   [ ] Do we separate the *.loc files from the other language files?

# Implementation

 [ ] Consider replacing Megaparsec parser with traditional LR parser, i.e. the
     Haskell equivalents of Flex and Bison, Alex and Happy. 
