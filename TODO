Immediate goals
 [x] add generics
 [ ] allow positional arrays in path
 [ ] allow functions in arrays
 [ ] replace `&` with `\`
 [ ] repeal and replace multiple composition
 [ ] add currying

Coming goals
 [ ] allow data structures for types
 [ ] perform Curry implicit typing
 [ ] generate linkers to resolve type incompatibilities
 [ ] add linkers to backend
 [ ] add `U x -> Bool` automatic checking
 [ ] add proper `import` sections

Distant goals
 [ ] add type constructors
 [ ] cross-reference existing types against an ontology of types



# ML reimplementation notes.

I need to cleanly separate the code into modular pieces. There are the standard
lexer and parser pieces.

Go back to my toy compilers. Reimplement each, in increasing order of
difficulty, in Haskell. Then implement Mouse in Haskell. Add full typechecking.
Add generics, parameterized types, everything. Formally express the type
checking and inference systems. Integrate the ontology. Add a way to add new
types. Add both import and include statements. Take care to separate the type
system from the grammar. The type system should operate at the function graph
level of abstraction; it should be independent of the particular method used to
build the function graph (e.g. whether I write Old Morloc or in Haskell).

I should replace LIL with DOT. A Morloc program can be well-represented by
a graph with attributes. This will simplify typing and also allow me to use all
the existing tools for working with and visualizing graphs.

I should not replace LIL with DOT. No, they serve different purposes. LIL is
a set of atomic instructions for building a program. DOT is higher level. I can
derive a LIL file from a DOT file (and vice versa).

Next I can expand the function graph to include language transitions and
assertions. If a slot of type `M x` connects to an input of type `N x`, I need
to generate two linking functions: `N x -> U x` and `U x -> M x`. Additionally,
I may want to add a runtime type checker, `U x -> Bool`. I should also add an
option to explode every call into a faux foreign call, so every call is
converted to universal and checked at runtime. This might be useful for
debugging. Now, it is important that these generated types be specified and
interwoven in the frontend, prior to generating LIL. This should not be the
backend's problem.

After all the typing is done, I can generate the manifold nexus and manifold
pools. The backend needs to know how to make `M x -> U x`, `U x -> M x` and
`U x -> Bool`.
