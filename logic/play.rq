# ----------------------------------------------------------------------------------------------------------
# | decname | dargs | callid  | falias         | element | argname | argcallname    | datatype   | dataval |
# ==========================================================================================================
# | "bar"   | "y"   | mlc:101 | "baz"          | rdf:_0  | "y"     |                |            |         |
# | "foo"   | "x"   | mlc:110 | "bar"          | rdf:_0  | "x"     |                |            |         |
# |         |       | mlc:25  | "len"          | rdf:_0  | "xs"    |                |            |         |
# | "roll"  | "d,n" | mlc:79  | "ceiling"      | rdf:_0  |         | "rand_uniform" |            |         |
# |         |       | mlc:81  | "rand_uniform" | rdf:_0  | "n"     |                |            |         |
# |         |       | mlc:81  | "rand_uniform" | rdf:_1  |         |                | mlc:number | 0.0     |
# |         |       | mlc:81  | "rand_uniform" | rdf:_2  | "d"     |                |            |         |
# | "baz"   | "z"   | mlc:92  | "ceiling"      | rdf:_0  | "z"     |                |            |         |
# ----------------------------------------------------------------------------------------------------------
PREFIX mlc: <http://www.morloc.io/ontology/000/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX mid: <http://www.morloc.io/XXX/mid/>
SELECT ?decname
       (group_concat(?darg; separator=",") as ?dargs)
       ?callid ?falias ?element ?argname ?argcallname ?datatype ?dataval
WHERE {
    ?callid rdf:type mlc:call ; 
            rdf:value ?fid .
    ?fid rdf:type mlc:name ;
         rdf:value ?falias .
    ?arg ?element ?callid .
    FILTER(regex(str(?element), "_[0-9]+$", "i"))
    OPTIONAL {
        ?datadec rdf:type mlc:dataDeclaration ;
                 mlc:lhs ?decname ;
                 mlc:rhs ?callid .
        ?dargid ?delement ?datadec ;
                rdf:type mlc:name ;
                rdf:value ?darg .
        FILTER(regex(str(?delement), "_[0-9]+$", "i"))
    }
    # A argument must be one of the following:
    #  1. raw data
    OPTIONAL {
        ?arg rdf:type mlc:data;
             rdf:type ?datatype ;
             rdf:value ?dataval .
        FILTER(?datatype != mlc:data)
    }
    #  2. a function call
    OPTIONAL {
        ?arg rdf:type mlc:name ; 
             rdf:value ?argname .
    }
    #  3. a name - the name can only come from 
    OPTIONAL {
        ?arg rdf:type mlc:call ;
             rdf:value ?argcallid .
        ?argcallid rdf:type mlc:name ;
                   rdf:value ?argcallname .
    }
}
GROUP BY ?decname ?dargs ?callid ?falias ?element ?argname ?argcallname ?datatype ?dataval
ORDER BY ?callid ?element




# find imports with the ".loc" extension
SELECT ?file
WHERE {
    ?import rdf:type morloc:import ;
            morloc:name ?file .
    FILTER (regex(?file, ".loc", "i"))
}

# Link Morloc types to language-specific types
CONSTRUCT { ?minput morloc:packsInto ?linput }
WHERE {
    # Morloc type declarations
    ?mtypedec rdf:type morloc:typeDeclaration ;
              morloc:lang "Morloc" ;
              morloc:lhs ?name ;
              morloc:rhs ?mrhs .
    # Corresponding language-specific type declarations
    ?ltypedec rdf:type morloc:typeDeclaration ;
              morloc:lang ?lang ;
              morloc:lhs ?name ;
              morloc:rhs ?lrhs .
    FILTER(?lang != "Morloc")
    # get the language-specific input types
    ?linput ?element ?lrhs .
    # map the elements to Morloc types
    ?minput ?element ?mrhs .
    # Require the elements really represent elements (should be a better way)
    FILTER(regex(str(?element), "_[0-9]+$", "i"))
}

# Map arg to its use within scope
SELECT ?argname ?arguse
WHERE {
    ?datadec rdf:type morloc:dataDeclaration .
    ?parameter ?element ?datadec ;
               rdf:type morloc:name ;
               rdf:value ?parameter_name .

    # TODO: this will require recursion down the call stack

    FILTER(regex(str(?element), "_[0-9]+$", "i"))
}

# is this is morloc script?
ASK
WHERE {
    ?source rdf:type morloc:script ;
}

# Link all function to their morloc types
CONSTRUCT {
    ?datadec morloc:type ?typedec
}
WHERE {
    ?typedec rdf:type morloc:typeDeclaration ;
             morloc:lhs ?name ;
             morloc:lang "Morloc" .
    ?datadec rdf:type morloc:dataDeclaration ;
             morloc:lhs ?name .
}

# Find all subjects/objects where object is not a URI
SELECT ?s ?o
WHERE {
    ?s rdf:type ?o .
    FILTER(!(isURI(?o)))
}

# Assert the object of any `rdf:type` predicate is a URI 
# This is a check of the Morloc implementation, not user input
ASK
WHERE {
    ?s rdf:type ?o .
    FILTER(!(isURI(?o)))
}

# Find any bad assignments (where the lhs is not a literal)
ASK
WHERE {
  ?s rdf:lhs ?o
  # find assignments
  { ?s rdf:type morloc:typeDeclaration }
  UNION
  { ?s rdf:type morloc:dataDeclaration }
  UNION
  { ?s rdf:type morloc:recordEntry }
  # remove triples where the lhs is not a literal
  FILTER(!isLiteral (?o))
}

# find any cases where there is a lhs but no rhs, or vice versa
SELECT ?s
WHERE {
  {
    { ?s morloc:lhs ?lhs }
    MINUS
    { ?s morloc:rhs ?rhs }
  }
  UNION
  {
    { ?s morloc:rhs ?lhs }
    MINUS
    { ?s morloc:lhs ?rhs }
  }
}

# passing on False: forall A where p exists B where p
ASK {
  ?type morloc:property ?p ;
        rdf:type morloc:type .

  NOT EXISTS {
    ?function morloc:property ?p 
              rdf:type morloc:functionType
  }
}
