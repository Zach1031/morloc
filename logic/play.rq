# find imports with the ".loc" extension
SELECT ?file
WHERE {
    ?import rdf:type morloc:import ;
            morloc:name ?file .
    FILTER (regex(?file, ".loc", "i"))
}

# Link Morloc types to language-specific types
CONSTRUCT { ?minput morloc:packsInto ?linput }
WHERE {
    # Morloc type declarations
    ?mtypedec rdf:type morloc:typeDeclaration ;
              morloc:lang "Morloc" ;
              morloc:lhs ?name ;
              morloc:rhs ?mrhs .
    # Corresponding language-specific type declarations
    ?ltypedec rdf:type morloc:typeDeclaration ;
              morloc:lang ?lang ;
              morloc:lhs ?name ;
              morloc:rhs ?lrhs .
    FILTER(?lang != "Morloc")
    # get the language-specific input types
    ?linput ?element ?lrhs .
    # map the elements to Morloc types
    ?minput ?element ?mrhs .
    # Require the elements really represent elements (should be a better way)
    FILTER(regex(str(?element), "_[0-9]+$", "i"))
}

# Map arg to its use within scope
SELECT ?argname ?arguse
WHERE {
    ?datadec rdf:type morloc:dataDeclaration .
    ?parameter ?element ?datadec ;
               rdf:type morloc:name ;
               rdf:value ?parameter_name .

    # TODO: this will require recursion down the call stack

    FILTER(regex(str(?element), "_[0-9]+$", "i"))
}

# is this is morloc script?
ASK
WHERE {
    ?source rdf:type morloc:script ;
}

# Link all function to their morloc types
CONSTRUCT {
    ?datadec morloc:type ?typedec
}
WHERE {
    ?typedec rdf:type morloc:typeDeclaration ;
             morloc:lhs ?name ;
             morloc:lang "Morloc" .
    ?datadec rdf:type morloc:dataDeclaration ;
             morloc:lhs ?name .
}

# Find all subjects/objects where object is not a URI
SELECT ?s ?o
WHERE {
    ?s rdf:type ?o .
    FILTER(!(isURI(?o)))
}

# Assert the object of any `rdf:type` predicate is a URI
# This is a check of the Morloc implementation, not user input
ASK
WHERE {
    ?s rdf:type ?o .
    FILTER(!(isURI(?o)))
}

# Find any bad assignments (where the lhs is not a literal)
ASK
WHERE {
  ?s rdf:lhs ?o
  # find assignments
  { ?s rdf:type morloc:typeDeclaration }
  UNION
  { ?s rdf:type morloc:dataDeclaration }
  UNION
  { ?s rdf:type morloc:recordEntry }
  # remove triples where the lhs is not a literal
  FILTER(!isLiteral (?o))
}

# find any cases where there is a lhs but no rhs, or vice versa
SELECT ?s
WHERE {
  {
    { ?s morloc:lhs ?lhs }
    MINUS
    { ?s morloc:rhs ?rhs }
  }
  UNION
  {
    { ?s morloc:rhs ?lhs }
    MINUS
    { ?s morloc:lhs ?rhs }
  }
}

# passing on False: forall A where p exists B where p
ASK {
  ?type morloc:property ?p ;
        rdf:type morloc:type .

  NOT EXISTS {
    ?function morloc:property ?p
              rdf:type morloc:functionType
  }
}
