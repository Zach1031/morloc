@comment

The code is long and repetitive.  Being repetitive is not good, of course, but
can be solved with a bit of sugar. More importantly, this script is very simple.

This is not a very fair way to compare times, since the R functions are native
calls and the python funcions are foreign.

# ===  t i m e . R  ====
#!/usr/bin/Rscript --vanilla
k <- commandArgs(trailingOnly=TRUE)
system.time(runif(k))
system.time(rnorm(k))
system.time(rexp(k))

# ===  t i m e . p y  ====
#!/usr/bin/env python3

import time
import sys

def time_func(f, *args):
    a = time.time()
    f(*args)
    b = time.time()
    return b - a

def py_runif(k):
    return [random.uniform(0,1) for x in range(k)] 

def py_rnorm(k):
    return [random.gauss(0,1) for x in range(k)] 

def py_rexp(k):
    return [random.expovariate(1) for x in range(k)] 

k = sys.args[1]

print(time_func(py_runif(k)))
print(time_func(py_rnorm(k)))
print(time_func(py_rxp(k)))

# ===  m a i n . s h  ====
#!/usr/bin/env bash

./time.R
./time.py

@include
core/atomic

@path R
Main :: null . *A *B *C
               *D *E *F
A :: *Time
B :: *Time
C :: *Time
D :: *Time
E :: *Time
F :: *Time

Time :: write . system.time . random . 1000000

@arg
write :: file="/dev/stderr"

@alias
Main/A/Time/random :: runif
Main/B/Time/random :: rnorm
Main/C/Time/random :: rexp
Main/D/Time/random :: py_runif
Main/E/Time/random :: py_rnorm
Main/F/Time/random :: py_rexp

@lang
Main/D/Time/random :: py
Main/E/Time/random :: py
Main/F/Time/random :: py

@source py
import random
def py_runif(k):
    return [random.uniform(0,1) for x in range(k)] 
def py_rnorm(k):
    return [random.gauss(0,1) for x in range(k)] 
def py_rexp(k):
    return [random.expovariate(1) for x in range(k)] 
