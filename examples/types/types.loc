# I still have not settled on a type system. I want to be able to specify input
# constraints in the type signatutes, but I don't want the full weight of a
# dependent type system. If we give up the static guarantee of correctness, we
# can assert these constraints at runtime.  In effect, this is just a
# formalization of the ad hoc assert statements we would add to the body of a
# function. These assumptions about the input, or properties of the output, are
# important enough to merit being specified at a high-level; they need to be
# considered carefully at the specification stage of development, also they are
# required for modeling the data.

L :: a -> Count

# L is a type constructor that takes two parameters, 1) the element type and 2)
# the list length. This latter type parameter is a random integer variable;
# constraints on its value can be set, it can be set to an absolute value, or
# it can be set to a distribution. By using `i` in each case, I set the
# constraint that the list length of each input and the output are the same.
foo :: L a1 i -> L a2 i -> L a3 i where
    a1,a2,a3 :: DUnif 0 1000

# The constraints in the 'where' clause will be checked at runtime, probably.
# It may sometimes be possible to prove the input constraints will be met,
# based on the output typesof the upstream functions. E.g.
bar :: Stuff -> L (DUnif 0 10) 5
baz :: Stuff -> L (DUnif 0 10) 5
foo (bar stuff1) (baz stuff2)
