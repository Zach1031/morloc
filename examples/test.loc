foo bar baz . bif


                .--- (b)
  (foo) --- (a) ---- (c) --- (d) --- (e)
                `--------------------'

# old morloc
foo . a . b (c . d . <e>) e

# haskell application
foo $ a b (c d <e>) e

# function definition
foo = a $ b (c $1) (d $2 $1) 1


# partial application
bar' = bar - 1 -

bar  :: a -> b -> c -> d
bar' :: a -> c -> d



     .--- (foo) ----   .--- (b)
(baz)               `(a) ---- (c) --- (d) --- (e)
     `--- (bar) ----'   `--------------------'

# old morloc
baz . foo bar . a . b (c . d . <e>) e

# hask
baz (foo <a>) (bar $ a b (c d <e>) e) 


 foo ----.
 bar ----- (a)
 baz ----'

# old morloc
foo bar baz . a

# hask
foo  a
bar <a>
baz <a>

# extended hask
foo , bar , baz $ a




# allow keyword arguments
foo x y k=1 r=2 . bar a b r=[2,3,4]

# rather than having the argument section, we can just use partial application
foo' := foo k=1 r=2

foo' x y . bar

# I also want to increase the versatility of the functions by allowing
# promotion of parameters

foo :: X -> Y  {a=1::Int, b=2::Num, c=[1,2]::[Int]}

bar := foo ^a  ::  X -> a -> Y

# This could be used to, for example, perform a parameter sweep


# Add constraints

runif :: n=Int , l=Num , u=Num -> r=[Num] where
    n       >= 1
    u       >= l
    dim(r)  =  n
    r_i     >= l
    r_i     <= u

# Where x_i indicates the ith element of x, where x is a traversable container

sort :: x=[a] -> y=[a] where
    Ord a 
    y_i <= y_{i+1}
    dim(x) = dim(y)

unique :: x=[a] -> y=[a] where
    Eq a
    y_i != y_j
    x_i in y
    y_i in x


# OK, but for now I need a minimal syntax, nothing experimental.

# 1. function application
# 2. declaration

foo a b (bar 23) | baz | biz a (bar 4)

  a (c 34 (c 9 1)) d
# 1  2 3   4 5 6   7

# All this syntax is really just syntactic sugar for the underlying directed
# graph structure:

# from to pos from_val fun
# 5    4  1   Int 9    c
# 6    4  2   Int 1    c
# 3    2  1   Int 34   c
# 4    2  2   Fun c    c
# 2    1  1   Fun c    a
# 7    1  2   Fun d    a
# 8    7  1   $1       d
