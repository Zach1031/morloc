@import
"some_stupid_crap"

@export
L0 as run_pipeline

@path
# main pathway
L0 :: L1 L2 --> D --> L3 --> F --> G;
L1 :: A:1 --> B;
L2 :: A:2 --> C;
L3 :: E;
# validators
vL1   :: L1 --> va;
vL2   :: L2 --> va;
vD    :: D --> vd;
vLots :: D F --> vabc;
# effectors
eA1B   :: A:1 B --> eab;
eA2C   :: A:2 C --> print;
eFinal :: (D --> x) (F --> y --> z) (G --> x) --> Q --> final;
# conditional test
CONNY :: x --> ( V ? A , B , C ) --> y

@compose
F = h . g . f

@alias
A = senhalatha
B = huzurbazar
C = fredericksen
D = alonganduninterestingname
E = someexpensiveoperation
F = andanother
G = thelastfunctioninthisparticularpipeline

@check
D  :: vL1
D  :: vL2
L3 :: vD
G  :: vLots

@effect
B :: eA1B
C :: eA2C
G :: eFinal

@arg
A:1 :: x=45, y="hi", z=[1,2,3]
A:2 :: x=46
E   :: x=45, y="df", z=[[1,['2',4]],2,3]
F   :: ttt=1

@cache
__all__ :: memcache
A       :: datcache
E       :: datcache
F       :: nocache
final   :: datcache

@pack
__all__ :: id

@open
__all__ :: id

@fail
__all__ :: null

@pass
__all__ :: call

@loop
with L1
 split A:1 on a=[1,2,3,4]
       B   on x=[1,2,5,9]
 merge using mergefunction

with L2
 split A:2 on b=['t','a','g']
 split C   on y=ys
 merge using mergefunction

with L3
 split using cut_input_into_chunks
 merge using merge_processed_chunks
